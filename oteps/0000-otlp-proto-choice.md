# Upgrading Protocols in OpenTelemetry

Proposes a set of requirements that a protocol can meet to qualify as
an OpenTelemetry protocol, admitting for alternatives when they have
correct equivalence, which includes non-lossy, bi-directional exchange
with OpenTelemetry Protocol (OTLP).

## Motivation

The OpenTelemetry Protocol (OTLP), currently version 1.9, stands as a
definition of the OpenTelemetry data model. Because of the close
connection with the data model, it is not a concise format. 

There have been efforts to improve on the compression performance of
the protocol, specifically, including the [OpenTelemetry Arrow
Protocol](https://github.com/open-telemetry/community/blob/main/projects/otelarrow.md)
(OTAP).  Now, the approach taken by OTel-Arrow for its Phase 1
components is used as a prototype for this proposal.

As OpenTelemetry has added a Profiles signal type, there is interest
in adding [optional encoding features to improve the OpenTelemetry
by adding a dictionary](https://github.com/open-telemetry/opentelemetry-proto/pull/733).

OpenTelemetry has maintained backwards compatibility with its 1.0
protocol specification, including through the addition of Entities in
the protocol and data model. The new Entity was added in the Protocol
alongside the Resource, which it conceptually extends. The use of
indirection, in this case, leads again to a less concise protocol.

## Explanation

We propose requirements that a protocol can meet to be considered a
viable alternative to the OpenTelemetry Protocol. This viability score
is signal-, OpenTelemetry version-, and transport-specific, meaning we
aim to answer the question: when is an alternate protocol (P)
compatible with an OpenTelemetry signal (S) at a OpenTelemetry
Protocol version (V) over some transport (T)?

Here we propose the following requirements:

1. Request-for-request equivalence. The protocol produces data with
   equal meaning for all aspects of the OpenTelemetry data model at a
   specific version of the v1.x
   `opentelemetry::proto::collector::{Signal}::v1` protocol, each
   individual `Export{Signal}ServiceRequest` object has an
   equivalent. Equivalence is defined in detail below.
2. Bi-directional, non-lossy. The protocol can be converted to and
   from OpenTelmetry Protocol message objects (for version V) without
   information loss, meaning into either the object generated by a
   Protocol Buffer Compiler or the official representative type. For
   the OpenTelemetry Collector, this means the `pdata` request object
   (e.g., `plog.Logs`).
3. HTTP and/or gRPC upgradeable. The protocol can be offered on the
   same receiver, using the same port as OTLP HTTP or gRPC using
   alternative request path and/or service names. Exporters can
   negotiate use of the new protocol, or they can fall back to
   OpenTelemetry Protocol using the same endpoint configuration.

The final requirement involves community approval and acceptance,
means implementing the Protocol as a built-in alternative protocol
extension. As an initial precondition for these requirements to pass
the OpenTelemetry Collector SHOULD add a new extension point for
alternative protocols AND either:

- Implement it in the core OTLP `otlpreceiver` and `otlpexporter`.
- Permit new `otelexporter` and `otelreceiver` components into the
  core that implement OpenTelemetry Protocol with alternative
  extensions and automatic OTLP fallback.
  
Using new a specification, the exporter and receiver will negotiate 
which protocols are supported and used at the connection level.

Following the initial precondition, to be accepted as an official 
alternative by the OpenTelemetry project means:

- Provide an implementation of the alternative protocol extension 
  for the OpenTelemetry Collector, for both the Exporter and Receiver
- Provide production-ready, hardened protocol conversion routines
  to and from the representative types (i.e., `pdata` objects)
- Provide standard conversion routines to and from OpenTelemetry
  Protocol message objects for demonstrating equivalence.

There is a built-in example for consideration as the initial
candidate. The OTLP HTTP/JSON protocol is fully supported in the
OpenTelemetry OTLP/HTTP receiver and exporter component, a built-in
alternative.

## Internal details

Our goal is that users can change the protocol that they use without
changing the OpenTelemetry component that exports and receives their
data. We believe that refinements to the OpenTelmetry Protocol can be
introduced gradually without breaking the existing uses, letting
OpenTelemetry Protocol continue to act as the data model standard in
OpenTelemetry, while we shift to more concise protocols in practice
that guarantee 100% equivalence.

We understand that users will not always want alternative protocols.
Alternative protocols through extensions, so that users can pick and
choose what their Collectors support.

As an explicit goal of this definition, we do not require SDKs to
adopt alternative Protocols, however an OpenTelemetry SDK exporter for
the alternative protocol can be used as a show of community support.

### OpenTelemetry Protocol with Apache Arrow

The OTel-Arrow project is used as an example because we believe it is
a good alternative. Following its Phase 1 deliverables, the project
has demonstrated:

- Complete OpenTelemetry Protocol equivalence through OTLP v1.5
- Combined OTLP and OTAP Protocol on one port with automatic fallback
  (Collector-Contrib `otelarrowexporter` and `otelarrowreceiver`)
- Conversion libraries for conversion to and from OpenTelemetry 
  Collector `pdata` object
- Substantial improvements in compression performance, independently 
  verified, with production usage.

The project has also implemented a second proof-of-concept Rust
pipeline for OpenTelemetry data, repeating all of this in a second
language.

### Alternative protocol negotiation

The specific mechanism used for clients and servers to negotiate
encoding between OpenTelemetry Exporter and Receiver is out of scope
in this OTEP. 

For receivers, specify how to indicate the accepted alternative
protocols. It would be natural to use an HTTP response trailer for
receivers to indicate their accepted encodings.

For exporters, user configuration can control the preferred export
encoding. It would be natural to use HTTP 501 ("Not implemented") and
gRPC code 12 ("UNIMPLEMENTED") receivers to indicate unacceptable
encodings.

### Equivalence testing allowances

One of the major techniques the OpenTelemetry Protocol with Apache
Arrow uses to its advantage in compression performance is the through
re-arranging the data so that it is more compressible without
substantively changing the data. 

For project requirements to be met, the alternative protocol must
demonstrate equivalence using a test framework.  Specfic equivalence
rules are described below.

#### Unordered lists

Unordered lists in OpenTelemetry can be re-ordered:

- Collections (e.g., ResourceLogs, ScopeLogs)
- Items (e.g,, Spans, LogRecords)
- Sub-items (e.g., Links, Events)

Re-ordering any of these elements does not change the data in ways 
that are relevant to the data model.

### Attribute ordering

Repeated `KeyValue` lists are frequent in the OpenTelemetry
protocol. These are maps in the data model, but they are lists in the
protocol, and their order is insiginficant.

The order of attributes is considered non semantic, with an important
caveat. In the case where an attribute key appears more than once in
the same list (i.e., a duplicate-key value), the `proto3` behavior
dictates that the last value wins. Therefore, if an alternative
protocol intends to re-order attributes, it MUST first ensure that
there are no duplicate keys.

#### Message field presence

While OpenTelemetry Protocol is defined in terms of Google Protocol
Buffer standard, and while the project uses `proto3` syntax in its own
definitions, object presence is not considered semantic information in
OpenTelemetry. The `proto3` definition for implicit message field
presence does not apply in the following cases:

- `Span::Status`: the alternative protocol is not required to
  distinguish between a present/default `Span::Status` and an unset
  `Span::Status`

#### Identifier defaults

The TraceID value `00000000000000000000000000000000` and SpanID value
`0000000000000000` are equivalent with unset TraceID and SpanID.

## Prototypes

The [OTel-Arrow project repository](https://github.com/open-telemetry/otel-arrow).

The Golang [combined OTAP/OTLP receiver](https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/receiver/otelarrowreceiver/README.md).

The Golang [combined OTAP/OTLP exporter](https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/exporter/otelarrowexporter/README.md).

## Prior art

The OTel-Arrow components support only gRPC transports. They use the
gRPC response code UNIMPLEMENTED as the indicator that a server sends
the client for unrecognized services; the OTel-Arrow components use
this as a signal to fall back to OTLP.

## Future possibilities

This proposal gives a pathway towards future alternative to OTLP, an
OTLP v2.x protocol that builds on the original its alternatives.
